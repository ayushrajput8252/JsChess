# -*- coding: utf-8 -*-
"""pytorch_leanring.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YbtHFLCNV-us59I2k5UnNVcn31W124Kt
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
import torch
import torch.nn as nn
from torch.utils.data import DataLoader, Dataset

df = pd.read_csv('/content/House Price Prediction Dataset.csv')

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
print(device)

df.isnull().sum()

df.head()

label = LabelEncoder()
df['Location'] = label.fit_transform(df['Location'])
df['Condition'] = label.fit_transform(df['Condition'])
df['Garage'] = label.fit_transform(df['Garage'])

df.head()

x = df.drop(columns=['Id', 'Price'], axis=1)
y = df['Price']

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

sd_x = StandardScaler()
x_train = sd_x.fit_transform(x_train)
x_test = sd_x.transform(x_test)

sd_y = StandardScaler()
y_train = sd_y.fit_transform(y_train.values.reshape(-1, 1))
y_test = sd_y.transform(y_test.values.reshape(-1, 1))

x_train = torch.tensor(x_train, dtype=torch.float32)
x_test = torch.tensor(x_test, dtype=torch.float32)
y_train = torch.tensor(y_train, dtype=torch.float32)
y_test = torch.tensor(y_test, dtype=torch.float32)

class CustomDataset(Dataset):
  def __init__(self, features, labels):
    self.features = features
    self.labels = labels

  def __len__(self):
    return len(self.features)

  def __getitem__(self, idx):
    return self.features[idx], self.labels[idx]

train_dataset = CustomDataset(x_train, y_train)
test_dataset = CustomDataset(x_test, y_test)

train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True, pin_memory=True)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False, pin_memory=True)

class RegressionModel(nn.Module):
    def __init__(self, input_dim):
        super(RegressionModel, self).__init__()
        self.fc1 = nn.Linear(input_dim, 64)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(64, 1)

    def forward(self, x):
        x = self.fc1(x)
        x = self.relu(x)
        x = self.fc2(x)
        return x

input_dim = x_train.shape[1] # Get the number of features
model = RegressionModel(input_dim).to(device)
criterion = nn.MSELoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

epochs = 10
for epoch in range(epochs):
  model.train()
  total_loss = 0
  for x_batch, y_batch in train_loader:
    optimizer.zero_grad()
    x_batch = x_batch.to(device)
    y_batch = y_batch.to(device).unsqueeze(1) # Ensure y_batch is 2D for MSELoss
    y_pred = model(x_batch)
    loss  = criterion(y_pred, y_batch)
    loss.backward()
    optimizer.step()
    total_loss += loss.item()
  avg_loss = total_loss / len(train_loader)
  print(f'Epoch [{epoch+1}/{epochs}], Loss: {avg_loss:.4f}')

